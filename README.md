# 꾸준실습 과제 내용 
- 프로젝트 자체는 강의 수강을 위해 만들어둔 프로젝트입니다.
- 리드미에서 풀이를 작성하고 있습니다.

## Q. 1-3 UI관련
### 앵커와 피벗은 같은 기능을 한다. (O/X)
- X 앵커는 화면에서의 중심점 피벗은 현재 UI의 중심점을 나타낸다.
### 피벗을 왼쪽 상단으로 설정하면, UI 요소는 화면의 왼쪽 상단을 기준으로 위치가 고정된다. (O/X)
- X 이것은 앵커의 설명이다.
### 피벗을 UI 요소의 중심에 설정하면, 회전 시 UI 요소가 중심을 기준으로 회전한다. (O/X)
- O 피벗을 0.5 0.5 로 설정하여 회전시키면 UI의 중심으로 회전이 된다.
### 게임의 상단바와 같이 화면에 특정 영역에 꽉 차게 구성되는 UI와 화면의 특정 영역에 특정한 크기로 등장하는 UI의 앵커 구성이 어떻게 다른 지 설명해보세요.
- 특정영역에 꽉차게 되는 UI의 경우 앵커를 UI 양 양옆 혹은 위아래 으로 고정시켜 해상도에 따라 크기가 조절되도록하고
- 특정영역의 크기로 등장하는 UI의 경우 해당 위치에 앵커를 UI의 중심 혹은 UI가장자리로 설정하여 화면에 따라 위치를 조절되게 한다.
### 돌아다니는 몬스터의 HP 바와 늘 고정되어있는 플레이어의 HP바는 Canvas 컴포넌트의 어떤 설정이 달라질 지 생각해보세요.
- PlAYER HP바와 같은 고정된 UI는 Scale with ScreenSize 옵션 상에 UI를 배치할 것 같고
- 돌아다니는 HP와 같은 경우 World Size 옵션인 Canvas를 해당 오브젝트의 자식으로 두어 따라다니게 하거나 Scale With ScreenSize 옵션하에 두고 화면상에서 오브젝트의 위치를 따라다니게 할 것 같습니다.

## Q.심화주차 1~4강 코루틴 관련
### 코루틴은 비동기 작업을 처리하기 위해 사용된다. (O/X)
- O 코루틴은 비동기 작업을 처리하기 위해 사용되지만 비동기는 아니다.
### yield return new WaitForSeconds(1);는 코루틴을 1초 동안 대기시킨다. (O/X)
- O yield return new WaitForSeconds(); 는 인자안의 초만큼 처리를 지연시킨다.
### 코루틴은 void를 반환하는 메소드의 형태로 구현된다. (O/X)
- X 코루틴은 IEnumrator 라는 인터페이스타입을 반환한다.
### 코루틴을 이미 실행중이라면 추가로 실행하지 않으려면 어떻게 처리해주면 될까요?
- 코루틴을 이미 실행중일 때의 bool조건을 걸어 중첩되지 않도록한다. 만일 돌아가고 있다면 bool이 true가되어 끝날때까지 조건이 걸리도록 설계
### 코루틴 실행 중 게임오브젝트가 파괴되더라도 코루틴의 실행이 정상적으로 지속될까요?
- 코루틴 자체는 다른 오브젝트에서 불러와서 사용도 가능하기에 지속될것으로 사용이 가능할 것 같다. 라고 생각했는데 코루틴은 해당 게임오브젝트가 비활성화 되거나 파괴되면 중지된다고한다.

## Q. 심화주차 1-5, 1-6강 추상클래스 관련
### 추상 클래스는 new를 통해 인스턴스화(instantiation)할 수 없다. (O/X)
- X 추상클래스는 인스턴스화 할수없다.
### 추상 클래스는 다른 클래스처럼 일반 메서드와 속성을 포함할 수 있다. (O/X)
- O 추상클래스도 포함이 가능하다.
### 추상 클래스를 상속받은 클래스는 추상 클래스의 모든 추상 메서드를 구현해야 한다. (O/X)
- O 구현부가없는 함수는 존재할수없기에 구현해야한다.
### C#에서 한 클래스는 여러 개의 추상 클래스를 상속받을 수 있다. (O/X)
- X C#에서 다중상속이 가능한것은 인터페이스뿐이다.
### 추상 클래스를 사용하지 않고 동일한 기능을 구현하려면 어떤 문제가 발생할 수 있는지 설명해보세요.
- 추상클래스를 사용하지 않고 동일한 기능을 구현하면 동일한 메서드를 상속받았을 때 서로 다르게 구분하기 힘들 것 같다. 물론 virtual 키워드를 사용하여 내용을 상속받을지 여부를 결정할수는 있겠지만 그렇게 하기보단 abstract 키워드를 사용하는 게 효율적일것같다.
